C51 COMPILER V9.52.0.0   PROTOCOL                                                          02/24/2021 22:17:58 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE PROTOCOL
OBJECT MODULE PLACED IN protocol.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE mcu_sdk\protocol.c COMPACT BROWSE INCDIR(.\mcu_sdk) DEBUG OBJECTEXTEND PRIN
                    -T(.\protocol.lst) OBJECT(protocol.obj)

line level    source

   1          /**********************************Copyright (c)**********************************
   2          **                       ç‰ˆæƒæ‰€æœ‰ (C), 2015-2020, æ¶‚é¸¦ç§‘æŠ€
   3          **
   4          **                             http://www.tuya.com
   5          **
   6          *********************************************************************************/
   7          /**
   8           * @file    protocol.c
   9           * @author  æ¶‚é¸¦ç»¼åˆåè®®å¼€å‘ç»„
  10           * @version v2.5.6
  11           * @date    2020.12.16
  12           * @brief                
  13           *                       *******éå¸¸é‡è¦ï¼Œä¸€å®šè¦çœ‹å“¦ï¼ï¼ï¼********
  14           *          1. ç”¨æˆ·åœ¨æ­¤æ–‡ä»¶ä¸­å®ç°æ•°æ®ä¸‹å‘/ä¸ŠæŠ¥åŠŸèƒ½
  15           *          2. DPçš„ID/TYPEåŠæ•°æ®å¤„ç†å‡½æ•°éƒ½éœ€è¦ç”¨æˆ·æŒ‰ç…§å®é™…å®šä¹‰å®ç°
  16           *          3. å½“å¼€å§‹æŸäº›å®å®šä¹‰åéœ€è¦ç”¨æˆ·å®ç°ä»£ç çš„å‡½æ•°å†…éƒ¨æœ‰#erræç¤º,å®Œæˆå‡½æ•
             -°åè¯·åˆ é™¤è¯¥#err
  17           */
  18          
  19          /****************************** å…è´£å£°æ˜ ï¼ï¼ï¼ *******************************
  20          ç”±äºMCUç±»å‹å’Œç¼–è¯‘ç¯å¢ƒå¤šç§å¤šæ ·ï¼Œæ‰€ä»¥æ­¤ä»£ç ä»…ä¾›å‚è€ƒï¼Œç”¨æˆ·è¯·è‡ªè¡ŒæŠŠæ§æœ€ç»ˆä»£ç
             - è´¨é‡ï¼Œ
  21          æ¶‚é¸¦ä¸å¯¹MCUåŠŸèƒ½ç»“æœè´Ÿè´£ã€‚
  22          ******************************************************************************/
  23          
  24          /******************************************************************************
  25                                          ç§»æ¤é¡»çŸ¥:
  26          1:MCUå¿…é¡»åœ¨whileä¸­ç›´æ¥è°ƒç”¨mcu_api.cå†…çš„wifi_uart_service()å‡½æ•°
  27          2:ç¨‹åºæ­£å¸¸åˆå§‹åŒ–å®Œæˆå,å»ºè®®ä¸è¿›è¡Œå…³ä¸²å£ä¸­æ–­,å¦‚å¿…é¡»å…³ä¸­æ–­,å…³ä¸­æ–­æ—¶é—´å¿…é¡»çŸ
             -­,å…³ä¸­æ–­ä¼šå¼•èµ·ä¸²å£æ•°æ®åŒ…ä¸¢å¤±
  28          3:è¯·å‹¿åœ¨ä¸­æ–­/å®šæ—¶å™¨ä¸­æ–­å†…è°ƒç”¨ä¸ŠæŠ¥å‡½æ•°
  29          ******************************************************************************/
  30          
  31          #include "wifi.h"
  32          
  33          extern void sendchar(unsigned char num) ;  ////20210215sdk
  34          extern unsigned int current_temp;
  35          
  36          #ifdef WEATHER_ENABLE
              
              /**
               * @var    weather_choose
               * @brief  å¤©æ°”æ•°æ®å‚æ•°é€‰æ‹©æ•°ç»„
               * @note   ç”¨æˆ·å¯ä»¥è‡ªå®šä¹‰éœ€è¦çš„å‚æ•°ï¼Œæ³¨é‡Šæˆ–è€…å–æ¶ˆæ³¨é‡Šå³å¯ï¼Œæ³¨æ„æ›´æ”¹
               */
              const char *weather_choose[WEATHER_CHOOSE_CNT] = {
                  "temp",
                  "humidity",
                  "condition",
                  "pm25",
                  /*"pressure",
                  "realFeel",
                  "uvi",
                  "tips",
C51 COMPILER V9.52.0.0   PROTOCOL                                                          02/24/2021 22:17:58 PAGE 2   

                  "windDir",
                  "windLevel",
                  "windSpeed",
                  "sunRise",
                  "sunSet",
                  "aqi",
                  "so2 ",
                  "rank",
                  "pm10",
                  "o3",
                  "no2",
                  "co",
                  "conditionNum",*/
              };
              #endif
  67          
  68          
  69          /******************************************************************************
  70                                        ç¬¬ä¸€æ­¥:åˆå§‹åŒ–
  71          1:åœ¨éœ€è¦ä½¿ç”¨åˆ°wifiç›¸å…³æ–‡ä»¶çš„æ–‡ä»¶ä¸­include "wifi.h"
  72          2:åœ¨MCUåˆå§‹åŒ–ä¸­è°ƒç”¨mcu_api.cæ–‡ä»¶ä¸­çš„wifi_protocol_init()å‡½æ•°
  73          3:å°†MCUä¸²å£å•å­—èŠ‚å‘é€å‡½æ•°å¡«å…¥protocol.cæ–‡ä»¶ä¸­uart_transmit_outputå‡½æ•°å†…,å¹¶åˆ é™¤#error
  74          4:åœ¨MCUä¸²å£æ¥æ”¶å‡½æ•°ä¸­è°ƒç”¨mcu_api.cæ–‡ä»¶å†…çš„uart_receive_inputå‡½æ•°,å¹¶å°†æ¥æ”¶åˆ°çš„å­—èŠ‚ä
             -½œä¸ºå‚æ•°ä¼ å…¥
  75          5:å•ç‰‡æœºè¿›å…¥whileå¾ªç¯åè°ƒç”¨mcu_api.cæ–‡ä»¶å†…çš„wifi_uart_service()å‡½æ•°
  76          ******************************************************************************/
  77          
  78          /******************************************************************************
  79                                  1:dpæ•°æ®ç‚¹åºåˆ—ç±»å‹å¯¹ç…§è¡¨
  80                    **æ­¤ä¸ºè‡ªåŠ¨ç”Ÿæˆä»£ç ,å¦‚åœ¨å¼€å‘å¹³å°æœ‰ç›¸å…³ä¿®æ”¹è¯·é‡æ–°ä¸‹è½½MCU_SDK**         
  81          ******************************************************************************/
  82          xdata const  DOWNLOAD_CMD_S download_cmd[] =  //20210215sdk
  83          {
  84            {DPID_TEMP_CURRENT, DP_TYPE_VALUE},
  85            {DPID_HUMIDITY_VALUE, DP_TYPE_VALUE},
  86            {DPID_BATTERY_STATE, DP_TYPE_ENUM},
  87            {DPID_BATTERY_PERCENTAGE, DP_TYPE_VALUE},
  88            {DPID_TAMPER_ALARM, DP_TYPE_BOOL},
  89            {DPID_TEMP_SAMPLING, DP_TYPE_VALUE},
  90            {DPID_HUMIDITY_SAMPLING, DP_TYPE_VALUE},
  91            {DPID_CHARGE_STATE, DP_TYPE_BOOL},
  92            {DPID_TEMP_UNIT_CONVERT, DP_TYPE_ENUM},
  93            {DPID_MAXTEMP_SET, DP_TYPE_VALUE},
  94            {DPID_MINITEMP_SET, DP_TYPE_VALUE},
  95            {DPID_MAXHUM_SET, DP_TYPE_VALUE},
  96            {DPID_MINIHUM_SET, DP_TYPE_VALUE},
  97            {DPID_TEMP_ALARM, DP_TYPE_ENUM},
  98            {DPID_HUM_ALARM, DP_TYPE_ENUM},
  99            {DPID_BRIGHT_VALUE, DP_TYPE_VALUE},
 100            {DPID_TEMP_PERIODIC_REPORT, DP_TYPE_VALUE},
 101            {DPID_HUM_PERIODIC_REPORT, DP_TYPE_VALUE},
 102            {DPID_TEMP_SENSITIVITY, DP_TYPE_VALUE},
 103            {DPID_HUM_SENSITIVITY, DP_TYPE_VALUE},
 104            {DPID_SWITCH, DP_TYPE_BOOL},
 105            {DPID_TEMP_SET, DP_TYPE_VALUE},
 106          };
 107          
 108          
 109          
 110          /******************************************************************************
 111                                     2:ä¸²å£å•å­—èŠ‚å‘é€å‡½æ•°
 112          è¯·å°†MCUä¸²å£å‘é€å‡½æ•°å¡«å…¥è¯¥å‡½æ•°å†…,å¹¶å°†æ¥æ”¶åˆ°çš„æ•°æ®ä½œä¸ºå‚æ•°ä¼ å…¥ä¸²å£å‘é€å‡½æ•°
C51 COMPILER V9.52.0.0   PROTOCOL                                                          02/24/2021 22:17:58 PAGE 3   

 113          ******************************************************************************/
 114          
 115          /**
 116           * @brief  ä¸²å£å‘é€æ•°æ®
 117           * @param[in] {value} ä¸²å£è¦å‘é€çš„1å­—èŠ‚æ•°æ®
 118           * @return Null
 119           */
 120          void uart_transmit_output(unsigned char value)
 121          {
 122   1          //#error "è¯·å°†MCUä¸²å£å‘é€å‡½æ•°å¡«å…¥è¯¥å‡½æ•°,å¹¶åˆ é™¤è¯¥è¡Œ"
 123   1          sendchar(value);  //20210215sdk
 124   1          
 125   1      /*
 126   1          //Example:
 127   1          extern void Uart_PutChar(unsigned char value);
 128   1          Uart_PutChar(value);                                        //ä¸²å£å‘é€å‡½æ•°
 129   1      */
 130   1      }
 131          
 132          /******************************************************************************
 133                                     ç¬¬äºŒæ­¥:å®ç°å…·ä½“ç”¨æˆ·å‡½æ•°
 134          1:APPä¸‹å‘æ•°æ®å¤„ç†
 135          2:æ•°æ®ä¸ŠæŠ¥å¤„ç†
 136          ******************************************************************************/
 137          
 138          /******************************************************************************
 139                                      1:æ‰€æœ‰æ•°æ®ä¸ŠæŠ¥å¤„ç†
 140          å½“å‰å‡½æ•°å¤„ç†å…¨éƒ¨æ•°æ®ä¸ŠæŠ¥(åŒ…æ‹¬å¯ä¸‹å‘/å¯ä¸ŠæŠ¥å’Œåªä¸ŠæŠ¥)
 141            éœ€è¦ç”¨æˆ·æŒ‰ç…§å®é™…æƒ…å†µå®ç°:
 142            1:éœ€è¦å®ç°å¯ä¸‹å‘/å¯ä¸ŠæŠ¥æ•°æ®ç‚¹ä¸ŠæŠ¥
 143            2:éœ€è¦å®ç°åªä¸ŠæŠ¥æ•°æ®ç‚¹ä¸ŠæŠ¥
 144          æ­¤å‡½æ•°ä¸ºMCUå†…éƒ¨å¿…é¡»è°ƒç”¨
 145          ç”¨æˆ·ä¹Ÿå¯è°ƒç”¨æ­¤å‡½æ•°å®ç°å…¨éƒ¨æ•°æ®ä¸ŠæŠ¥
 146          ******************************************************************************/
 147          
 148          //è‡ªåŠ¨åŒ–ç”Ÿæˆæ•°æ®ä¸ŠæŠ¥å‡½æ•°
 149          
 150          /**
 151           * @brief  ç³»ç»Ÿæ‰€æœ‰dpç‚¹ä¿¡æ¯ä¸Šä¼ ,å®ç°APPå’Œmucæ•°æ®åŒæ­¥
 152           * @param  Null
 153           * @return Null
 154           * @note   æ­¤å‡½æ•°SDKå†…éƒ¨éœ€è°ƒç”¨ï¼ŒMCUå¿…é¡»å®ç°è¯¥å‡½æ•°å†…æ•°æ®ä¸ŠæŠ¥åŠŸèƒ½ï¼ŒåŒ…æ‹¬åªä¸ŠæŠ¥å’
             -Œå¯ä¸ŠæŠ¥å¯ä¸‹å‘å‹æ•°æ®
 155           */
 156          void all_data_update(void)
 157          {
 158   1          //#error "è¯·åœ¨æ­¤å¤„ç†å¯ä¸‹å‘å¯ä¸ŠæŠ¥æ•°æ®åŠåªä¸ŠæŠ¥æ•°æ®ç¤ºä¾‹,å¤„ç†å®Œæˆååˆ é™¤è¯¥è¡Œ"
 159   1          
 160   1          //æ­¤ä»£ç ä¸ºå¹³å°è‡ªåŠ¨ç”Ÿæˆï¼Œè¯·æŒ‰ç…§å®é™…æ•°æ®ä¿®æ”¹æ¯ä¸ªå¯ä¸‹å‘å¯ä¸ŠæŠ¥å‡½æ•°å’Œåªä¸Šæ
             -Š¥å‡½æ•°
 161   1          mcu_dp_value_update(DPID_TEMP_CURRENT,current_temp); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
 162   1          /*mcu_dp_value_update(DPID_HUMIDITY_VALUE,å½“å‰å½“å‰æ¹¿åº¦); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
 163   1          mcu_dp_enum_update(DPID_BATTERY_STATE,å½“å‰ç”µæ± ç”µé‡çŠ¶æ€); //æšä¸¾å‹æ•°æ®ä¸ŠæŠ¥;
 164   1          mcu_dp_value_update(DPID_BATTERY_PERCENTAGE,å½“å‰ç”µæ± ç”µé‡); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
 165   1          mcu_dp_bool_update(DPID_TAMPER_ALARM,å½“å‰é˜²æ‹†æŠ¥è­¦); //BOOLå‹æ•°æ®ä¸ŠæŠ¥;
 166   1          mcu_dp_value_update(DPID_TEMP_SAMPLING,å½“å‰æ¸©åº¦é‡‡æ ·æ—¶é—´è®¾ç½®); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
 167   1          mcu_dp_value_update(DPID_HUMIDITY_SAMPLING,å½“å‰æ¹¿åº¦é‡‡æ ·æ—¶é—´è®¾ç½®); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
 168   1          mcu_dp_bool_update(DPID_CHARGE_STATE,å½“å‰å……ç”µçŠ¶æ€); //BOOLå‹æ•°æ®ä¸ŠæŠ¥;
 169   1          mcu_dp_enum_update(DPID_TEMP_UNIT_CONVERT,å½“å‰æ¸©æ ‡åˆ‡æ¢); //æšä¸¾å‹æ•°æ®ä¸ŠæŠ¥;
 170   1          mcu_dp_value_update(DPID_MAXTEMP_SET,å½“å‰æ¸©åº¦ä¸Šé™è®¾ç½®); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
 171   1          mcu_dp_value_update(DPID_MINITEMP_SET,å½“å‰æ¸©åº¦ä¸‹é™è®¾ç½®); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
 172   1          mcu_dp_value_update(DPID_MAXHUM_SET,å½“å‰æ¹¿åº¦ä¸Šé™è®¾ç½®); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
C51 COMPILER V9.52.0.0   PROTOCOL                                                          02/24/2021 22:17:58 PAGE 4   

 173   1          mcu_dp_value_update(DPID_MINIHUM_SET,å½“å‰æ¹¿åº¦ä¸‹é™è®¾ç½®); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
 174   1          mcu_dp_enum_update(DPID_TEMP_ALARM,å½“å‰æ¸©åº¦æŠ¥è­¦); //æšä¸¾å‹æ•°æ®ä¸ŠæŠ¥;
 175   1          mcu_dp_enum_update(DPID_HUM_ALARM,å½“å‰æ¹¿åº¦æŠ¥è­¦); //æšä¸¾å‹æ•°æ®ä¸ŠæŠ¥;
 176   1          mcu_dp_value_update(DPID_BRIGHT_VALUE,å½“å‰å½“å‰äº®åº¦å€¼); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
 177   1          mcu_dp_value_update(DPID_TEMP_PERIODIC_REPORT,å½“å‰æ¸©åº¦å‘¨æœŸä¸ŠæŠ¥); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
 178   1          mcu_dp_value_update(DPID_HUM_PERIODIC_REPORT,å½“å‰æ¹¿åº¦å‘¨æœŸä¸ŠæŠ¥); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
 179   1          mcu_dp_value_update(DPID_TEMP_SENSITIVITY,å½“å‰æ¸©åº¦çµæ•åº¦); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
 180   1          mcu_dp_value_update(DPID_HUM_SENSITIVITY,å½“å‰æ¹¿åº¦çµæ•åº¦); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
 181   1          mcu_dp_bool_update(DPID_SWITCH,å½“å‰å¼€å…³); //BOOLå‹æ•°æ®ä¸ŠæŠ¥;
 182   1          mcu_dp_value_update(DPID_TEMP_SET,å½“å‰æ¸©åº¦è®¾ç½®); //VALUEå‹æ•°æ®ä¸ŠæŠ¥;
 183   1      */
 184   1          
 185   1      }
 186          
 187          
 188          /******************************************************************************
 189                                          WARNING!!!    
 190                                      2:æ‰€æœ‰æ•°æ®ä¸ŠæŠ¥å¤„ç†
 191          è‡ªåŠ¨åŒ–ä»£ç æ¨¡æ¿å‡½æ•°,å…·ä½“è¯·ç”¨æˆ·è‡ªè¡Œå®ç°æ•°æ®å¤„ç†
 192          ******************************************************************************/
 193          /*****************************************************************************
 194          å‡½æ•°åç§° : dp_download_temp_sampling_handle
 195          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_TEMP_SAMPLINGçš„å¤„ç†å‡½æ•°
 196          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 197                  : length:æ•°æ®é•¿åº¦
 198          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 199          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 200          *****************************************************************************/
 201          static unsigned char dp_download_temp_sampling_handle(const unsigned char value[], unsigned short length)
 202          {
 203   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºVALUE
 204   1          unsigned char ret;
 205   1          unsigned long temp_sampling;
 206   1          
 207   1          temp_sampling = mcu_get_dp_download_value(value,length);
 208   1          /*
 209   1          //VALUEç±»å‹æ•°æ®å¤„ç†
 210   1          
 211   1          */
 212   1          
 213   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 214   1          ret = mcu_dp_value_update(DPID_TEMP_SAMPLING,temp_sampling);
 215   1          if(ret == SUCCESS)
 216   1              return SUCCESS;
 217   1          else
 218   1              return ERROR;
 219   1      }
 220          /*****************************************************************************
 221          å‡½æ•°åç§° : dp_download_humidity_sampling_handle
 222          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_HUMIDITY_SAMPLINGçš„å¤„ç†å‡½æ•°
 223          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 224                  : length:æ•°æ®é•¿åº¦
 225          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 226          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 227          *****************************************************************************/
 228          static unsigned char dp_download_humidity_sampling_handle(const unsigned char value[], unsigned short leng
             -th)
 229          {
 230   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºVALUE
 231   1          unsigned char ret;
 232   1          unsigned long humidity_sampling;
 233   1          
C51 COMPILER V9.52.0.0   PROTOCOL                                                          02/24/2021 22:17:58 PAGE 5   

 234   1          humidity_sampling = mcu_get_dp_download_value(value,length);
 235   1          /*
 236   1          //VALUEç±»å‹æ•°æ®å¤„ç†
 237   1          
 238   1          */
 239   1          
 240   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 241   1          ret = mcu_dp_value_update(DPID_HUMIDITY_SAMPLING,humidity_sampling);
 242   1          if(ret == SUCCESS)
 243   1              return SUCCESS;
 244   1          else
 245   1              return ERROR;
 246   1      }
 247          /*****************************************************************************
 248          å‡½æ•°åç§° : dp_download_temp_unit_convert_handle
 249          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_TEMP_UNIT_CONVERTçš„å¤„ç†å‡½æ•°
 250          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 251                  : length:æ•°æ®é•¿åº¦
 252          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 253          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 254          *****************************************************************************/
 255          static unsigned char dp_download_temp_unit_convert_handle(const unsigned char value[], unsigned short leng
             -th)
 256          {
 257   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºENUM
 258   1          unsigned char ret;
 259   1          unsigned char temp_unit_convert;
 260   1          
 261   1          temp_unit_convert = mcu_get_dp_download_enum(value,length);
 262   1          switch(temp_unit_convert) {
 263   2              case 0:
 264   2              break;
 265   2              
 266   2              case 1:
 267   2              break;
 268   2              
 269   2              default:
 270   2          
 271   2              break;
 272   2          }
 273   1          
 274   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 275   1          ret = mcu_dp_enum_update(DPID_TEMP_UNIT_CONVERT, temp_unit_convert);
 276   1          if(ret == SUCCESS)
 277   1              return SUCCESS;
 278   1          else
 279   1              return ERROR;
 280   1      }
 281          /*****************************************************************************
 282          å‡½æ•°åç§° : dp_download_maxtemp_set_handle
 283          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_MAXTEMP_SETçš„å¤„ç†å‡½æ•°
 284          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 285                  : length:æ•°æ®é•¿åº¦
 286          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 287          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 288          *****************************************************************************/
 289          static unsigned char dp_download_maxtemp_set_handle(const unsigned char value[], unsigned short length)
 290          {
 291   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºVALUE
 292   1          unsigned char ret;
 293   1          xdata unsigned long maxtemp_set;
 294   1          
C51 COMPILER V9.52.0.0   PROTOCOL                                                          02/24/2021 22:17:58 PAGE 6   

 295   1          maxtemp_set = mcu_get_dp_download_value(value,length);
 296   1          /*
 297   1          //VALUEç±»å‹æ•°æ®å¤„ç†
 298   1          
 299   1          */
 300   1          
 301   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 302   1          ret = mcu_dp_value_update(DPID_MAXTEMP_SET,maxtemp_set);
 303   1          if(ret == SUCCESS)
 304   1              return SUCCESS;
 305   1          else
 306   1              return ERROR;
 307   1      }
 308          /*****************************************************************************
 309          å‡½æ•°åç§° : dp_download_minitemp_set_handle
 310          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_MINITEMP_SETçš„å¤„ç†å‡½æ•°
 311          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 312                  : length:æ•°æ®é•¿åº¦
 313          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 314          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 315          *****************************************************************************/
 316          static unsigned char dp_download_minitemp_set_handle(const unsigned char value[], unsigned short length)
 317          {
 318   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºVALUE
 319   1          unsigned char ret;
 320   1          unsigned long minitemp_set;
 321   1          
 322   1          minitemp_set = mcu_get_dp_download_value(value,length);
 323   1          /*
 324   1          //VALUEç±»å‹æ•°æ®å¤„ç†
 325   1          
 326   1          */
 327   1          
 328   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 329   1          ret = mcu_dp_value_update(DPID_MINITEMP_SET,minitemp_set);
 330   1          if(ret == SUCCESS)
 331   1              return SUCCESS;
 332   1          else
 333   1              return ERROR;
 334   1      }
 335          /*****************************************************************************
 336          å‡½æ•°åç§° : dp_download_maxhum_set_handle
 337          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_MAXHUM_SETçš„å¤„ç†å‡½æ•°
 338          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 339                  : length:æ•°æ®é•¿åº¦
 340          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 341          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 342          *****************************************************************************/
 343          static unsigned char dp_download_maxhum_set_handle(const unsigned char value[], unsigned short length)
 344          {
 345   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºVALUE
 346   1          unsigned char ret;
 347   1          unsigned long maxhum_set;
 348   1          
 349   1          maxhum_set = mcu_get_dp_download_value(value,length);
 350   1          /*
 351   1          //VALUEç±»å‹æ•°æ®å¤„ç†
 352   1          
 353   1          */
 354   1          
 355   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 356   1          ret = mcu_dp_value_update(DPID_MAXHUM_SET,maxhum_set);
C51 COMPILER V9.52.0.0   PROTOCOL                                                          02/24/2021 22:17:58 PAGE 7   

 357   1          if(ret == SUCCESS)
 358   1              return SUCCESS;
 359   1          else
 360   1              return ERROR;
 361   1      }
 362          /*****************************************************************************
 363          å‡½æ•°åç§° : dp_download_minihum_set_handle
 364          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_MINIHUM_SETçš„å¤„ç†å‡½æ•°
 365          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 366                  : length:æ•°æ®é•¿åº¦
 367          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 368          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 369          *****************************************************************************/
 370          static unsigned char dp_download_minihum_set_handle(const unsigned char value[], unsigned short length)
 371          {
 372   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºVALUE
 373   1          unsigned char ret;
 374   1          unsigned long minihum_set;
 375   1          
 376   1          minihum_set = mcu_get_dp_download_value(value,length);
 377   1          /*
 378   1          //VALUEç±»å‹æ•°æ®å¤„ç†
 379   1          
 380   1          */
 381   1          
 382   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 383   1          ret = mcu_dp_value_update(DPID_MINIHUM_SET,minihum_set);
 384   1          if(ret == SUCCESS)
 385   1              return SUCCESS;
 386   1          else
 387   1              return ERROR;
 388   1      }
 389          /*****************************************************************************
 390          å‡½æ•°åç§° : dp_download_bright_value_handle
 391          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_BRIGHT_VALUEçš„å¤„ç†å‡½æ•°
 392          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 393                  : length:æ•°æ®é•¿åº¦
 394          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 395          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 396          *****************************************************************************/
 397          static unsigned char dp_download_bright_value_handle(const unsigned char value[], unsigned short length)
 398          {
 399   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºVALUE
 400   1          unsigned char ret;
 401   1          unsigned long bright_value;
 402   1          
 403   1          bright_value = mcu_get_dp_download_value(value,length);
 404   1          /*
 405   1          //VALUEç±»å‹æ•°æ®å¤„ç†
 406   1          
 407   1          */
 408   1          
 409   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 410   1          ret = mcu_dp_value_update(DPID_BRIGHT_VALUE,bright_value);
 411   1          if(ret == SUCCESS)
 412   1              return SUCCESS;
 413   1          else
 414   1              return ERROR;
 415   1      }
 416          /*****************************************************************************
 417          å‡½æ•°åç§° : dp_download_temp_periodic_report_handle
 418          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_TEMP_PERIODIC_REPORTçš„å¤„ç†å‡½æ•°
C51 COMPILER V9.52.0.0   PROTOCOL                                                          02/24/2021 22:17:58 PAGE 8   

 419          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 420                  : length:æ•°æ®é•¿åº¦
 421          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 422          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 423          *****************************************************************************/
 424          static unsigned char dp_download_temp_periodic_report_handle(const unsigned char value[], unsigned short l
             -ength)
 425          {
 426   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºVALUE
 427   1          unsigned char ret;
 428   1          unsigned long temp_periodic_report;
 429   1          
 430   1          temp_periodic_report = mcu_get_dp_download_value(value,length);
 431   1          /*
 432   1          //VALUEç±»å‹æ•°æ®å¤„ç†
 433   1          
 434   1          */
 435   1          
 436   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 437   1          ret = mcu_dp_value_update(DPID_TEMP_PERIODIC_REPORT,temp_periodic_report);
 438   1          if(ret == SUCCESS)
 439   1              return SUCCESS;
 440   1          else
 441   1              return ERROR;
 442   1      }
 443          /*****************************************************************************
 444          å‡½æ•°åç§° : dp_download_hum_periodic_report_handle
 445          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_HUM_PERIODIC_REPORTçš„å¤„ç†å‡½æ•°
 446          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 447                  : length:æ•°æ®é•¿åº¦
 448          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 449          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 450          *****************************************************************************/
 451          static unsigned char dp_download_hum_periodic_report_handle(const unsigned char value[], unsigned short le
             -ngth)
 452          {
 453   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºVALUE
 454   1          unsigned char ret;
 455   1          unsigned long hum_periodic_report;
 456   1          
 457   1          hum_periodic_report = mcu_get_dp_download_value(value,length);
 458   1          /*
 459   1          //VALUEç±»å‹æ•°æ®å¤„ç†
 460   1          
 461   1          */
 462   1          
 463   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 464   1          ret = mcu_dp_value_update(DPID_HUM_PERIODIC_REPORT,hum_periodic_report);
 465   1          if(ret == SUCCESS)
 466   1              return SUCCESS;
 467   1          else
 468   1              return ERROR;
 469   1      }
 470          /*****************************************************************************
 471          å‡½æ•°åç§° : dp_download_temp_sensitivity_handle
 472          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_TEMP_SENSITIVITYçš„å¤„ç†å‡½æ•°
 473          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 474                  : length:æ•°æ®é•¿åº¦
 475          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 476          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 477          *****************************************************************************/
 478          static unsigned char dp_download_temp_sensitivity_handle(const unsigned char value[], unsigned short lengt
C51 COMPILER V9.52.0.0   PROTOCOL                                                          02/24/2021 22:17:58 PAGE 9   

             -h)
 479          {
 480   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºVALUE
 481   1          unsigned char ret;
 482   1          unsigned long temp_sensitivity;
 483   1          
 484   1          temp_sensitivity = mcu_get_dp_download_value(value,length);
 485   1          /*
 486   1          //VALUEç±»å‹æ•°æ®å¤„ç†
 487   1          
 488   1          */
 489   1          
 490   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 491   1          ret = mcu_dp_value_update(DPID_TEMP_SENSITIVITY,temp_sensitivity);
 492   1          if(ret == SUCCESS)
 493   1              return SUCCESS;
 494   1          else
 495   1              return ERROR;
 496   1      }
 497          /*****************************************************************************
 498          å‡½æ•°åç§° : dp_download_hum_sensitivity_handle
 499          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_HUM_SENSITIVITYçš„å¤„ç†å‡½æ•°
 500          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 501                  : length:æ•°æ®é•¿åº¦
 502          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 503          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 504          *****************************************************************************/
 505          static unsigned char dp_download_hum_sensitivity_handle(const unsigned char value[], unsigned short length
             -)
 506          {
 507   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºVALUE
 508   1          unsigned char ret;
 509   1          unsigned long hum_sensitivity;
 510   1          
 511   1          hum_sensitivity = mcu_get_dp_download_value(value,length);
 512   1          /*
 513   1          //VALUEç±»å‹æ•°æ®å¤„ç†
 514   1          
 515   1          */
 516   1          
 517   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 518   1          ret = mcu_dp_value_update(DPID_HUM_SENSITIVITY,hum_sensitivity);
 519   1          if(ret == SUCCESS)
 520   1              return SUCCESS;
 521   1          else
 522   1              return ERROR;
 523   1      }
 524          /*****************************************************************************
 525          å‡½æ•°åç§° : dp_download_switch_handle
 526          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_SWITCHçš„å¤„ç†å‡½æ•°
 527          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 528                  : length:æ•°æ®é•¿åº¦
 529          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 530          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 531          *****************************************************************************/
 532          static unsigned char dp_download_switch_handle(const unsigned char value[], unsigned short length)
 533          {
 534   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºBOOL
 535   1          unsigned char ret;
 536   1          //0:å…³/1:å¼€
 537   1          unsigned char switch_1;
 538   1          
C51 COMPILER V9.52.0.0   PROTOCOL                                                          02/24/2021 22:17:58 PAGE 10  

 539   1          switch_1 = mcu_get_dp_download_bool(value,length);
 540   1          if(switch_1 == 0) {
 541   2              //å¼€å…³å…³
 542   2          }else {
 543   2              //å¼€å…³å¼€
 544   2          }
 545   1        
 546   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 547   1          ret = mcu_dp_bool_update(DPID_SWITCH,switch_1);
 548   1          if(ret == SUCCESS)
 549   1              return SUCCESS;
 550   1          else
 551   1              return ERROR;
 552   1      }
 553          /*****************************************************************************
 554          å‡½æ•°åç§° : dp_download_temp_set_handle
 555          åŠŸèƒ½æè¿° : é’ˆå¯¹DPID_TEMP_SETçš„å¤„ç†å‡½æ•°
 556          è¾“å…¥å‚æ•° : value:æ•°æ®æºæ•°æ®
 557                  : length:æ•°æ®é•¿åº¦
 558          è¿”å›å‚æ•° : æˆåŠŸè¿”å›:SUCCESS/å¤±è´¥è¿”å›:ERROR
 559          ä½¿ç”¨è¯´æ˜ : å¯ä¸‹å‘å¯ä¸ŠæŠ¥ç±»å‹,éœ€è¦åœ¨å¤„ç†å®Œæ•°æ®åä¸ŠæŠ¥å¤„ç†ç»“æœè‡³app
 560          *****************************************************************************/
 561          static unsigned char dp_download_temp_set_handle(const unsigned char value[], unsigned short length)
 562          {
 563   1          //ç¤ºä¾‹:å½“å‰DPç±»å‹ä¸ºVALUE
 564   1          unsigned char ret;
 565   1          unsigned long temp_set;
 566   1          
 567   1          temp_set = mcu_get_dp_download_value(value,length);
 568   1          /*
 569   1          //VALUEç±»å‹æ•°æ®å¤„ç†
 570   1          
 571   1          */
 572   1          
 573   1          //å¤„ç†å®ŒDPæ•°æ®ååº”æœ‰åé¦ˆ
 574   1          ret = mcu_dp_value_update(DPID_TEMP_SET,temp_set);
 575   1          if(ret == SUCCESS)
 576   1              return SUCCESS;
 577   1          else
 578   1              return ERROR;
 579   1      }
 580          
 581          
 582          
 583          
 584          /******************************************************************************
 585                                          WARNING!!!                     
 586          æ­¤éƒ¨åˆ†å‡½æ•°ç”¨æˆ·è¯·å‹¿ä¿®æ”¹!!
 587          ******************************************************************************/
 588          
 589          /**
 590           * @brief  dpä¸‹å‘å¤„ç†å‡½æ•°
 591           * @param[in] {dpid} dpid åºå·
 592           * @param[in] {value} dpæ•°æ®ç¼“å†²åŒºåœ°å€
 593           * @param[in] {length} dpæ•°æ®é•¿åº¦
 594           * @return dpå¤„ç†ç»“æœ
 595           * -           0(ERROR): å¤±è´¥
 596           * -           1(SUCCESS): æˆåŠŸ
 597           * @note   è¯¥å‡½æ•°ç”¨æˆ·ä¸èƒ½ä¿®æ”¹
 598           */
 599          unsigned char dp_download_handle(unsigned char dpid,const unsigned char value[], unsigned short length)
 600          {
C51 COMPILER V9.52.0.0   PROTOCOL                                                          02/24/2021 22:17:58 PAGE 11  

 601   1          /*********************************
 602   1          å½“å‰å‡½æ•°å¤„ç†å¯ä¸‹å‘/å¯ä¸ŠæŠ¥æ•°æ®è°ƒç”¨                    
 603   1          å…·ä½“å‡½æ•°å†…éœ€è¦å®ç°ä¸‹å‘æ•°æ®å¤„ç†
 604   1          å®Œæˆç”¨éœ€è¦å°†å¤„ç†ç»“æœåé¦ˆè‡³APPç«¯,å¦åˆ™APPä¼šè®¤ä¸ºä¸‹å‘å¤±è´¥
 605   1          ***********************************/
 606   1          unsigned char ret;
 607   1          switch(dpid) {
 608   2              case DPID_TEMP_SAMPLING:
 609   2                  //æ¸©åº¦é‡‡æ ·æ—¶é—´è®¾ç½®å¤„ç†å‡½æ•°
 610   2                  ret = dp_download_temp_sampling_handle(value,length);
 611   2              break;
 612   2              case DPID_HUMIDITY_SAMPLING:
 613   2                  //æ¹¿åº¦é‡‡æ ·æ—¶é—´è®¾ç½®å¤„ç†å‡½æ•°
 614   2                  ret = dp_download_humidity_sampling_handle(value,length);
 615   2              break;
 616   2              case DPID_TEMP_UNIT_CONVERT:
 617   2                  //æ¸©æ ‡åˆ‡æ¢å¤„ç†å‡½æ•°
 618   2                  ret = dp_download_temp_unit_convert_handle(value,length);
 619   2              break;
 620   2              case DPID_MAXTEMP_SET:
 621   2                  //æ¸©åº¦ä¸Šé™è®¾ç½®å¤„ç†å‡½æ•°
 622   2                  ret = dp_download_maxtemp_set_handle(value,length);
 623   2              break;
 624   2              case DPID_MINITEMP_SET:
 625   2                  //æ¸©åº¦ä¸‹é™è®¾ç½®å¤„ç†å‡½æ•°
 626   2                  ret = dp_download_minitemp_set_handle(value,length);
 627   2              break;
 628   2              case DPID_MAXHUM_SET:
 629   2                  //æ¹¿åº¦ä¸Šé™è®¾ç½®å¤„ç†å‡½æ•°
 630   2                  ret = dp_download_maxhum_set_handle(value,length);
 631   2              break;
 632   2              case DPID_MINIHUM_SET:
 633   2                  //æ¹¿åº¦ä¸‹é™è®¾ç½®å¤„ç†å‡½æ•°
 634   2                  ret = dp_download_minihum_set_handle(value,length);
 635   2              break;
 636   2              case DPID_BRIGHT_VALUE:
 637   2                  //å½“å‰äº®åº¦å€¼å¤„ç†å‡½æ•°
 638   2                  ret = dp_download_bright_value_handle(value,length);
 639   2              break;
 640   2              case DPID_TEMP_PERIODIC_REPORT:
 641   2                  //æ¸©åº¦å‘¨æœŸä¸ŠæŠ¥å¤„ç†å‡½æ•°
 642   2                  ret = dp_download_temp_periodic_report_handle(value,length);
 643   2              break;
 644   2              case DPID_HUM_PERIODIC_REPORT:
 645   2                  //æ¹¿åº¦å‘¨æœŸä¸ŠæŠ¥å¤„ç†å‡½æ•°
 646   2                  ret = dp_download_hum_periodic_report_handle(value,length);
 647   2              break;
 648   2              case DPID_TEMP_SENSITIVITY:
 649   2                  //æ¸©åº¦çµæ•åº¦å¤„ç†å‡½æ•°
 650   2                  ret = dp_download_temp_sensitivity_handle(value,length);
 651   2              break;
 652   2              case DPID_HUM_SENSITIVITY:
 653   2                  //æ¹¿åº¦çµæ•åº¦å¤„ç†å‡½æ•°
 654   2                  ret = dp_download_hum_sensitivity_handle(value,length);
 655   2              break;
 656   2              case DPID_SWITCH:
 657   2                  //å¼€å…³å¤„ç†å‡½æ•°
 658   2                  ret = dp_download_switch_handle(value,length);
 659   2              break;
 660   2              case DPID_TEMP_SET:
 661   2                  //æ¸©åº¦è®¾ç½®å¤„ç†å‡½æ•°
 662   2                  ret = dp_download_temp_set_handle(value,length);
C51 COMPILER V9.52.0.0   PROTOCOL                                                          02/24/2021 22:17:58 PAGE 12  

 663   2              break;
 664   2      
 665   2              
 666   2              default:
 667   2              break;
 668   2          }
 669   1          return ret;
 670   1      }
 671          
 672          /**
 673           * @brief  è·å–æ‰€æœ‰dpå‘½ä»¤æ€»å’Œ
 674           * @param[in] Null
 675           * @return ä¸‹å‘å‘½ä»¤æ€»å’Œ
 676           * @note   è¯¥å‡½æ•°ç”¨æˆ·ä¸èƒ½ä¿®æ”¹
 677           */
 678          unsigned char get_download_cmd_total(void)
 679          {
 680   1          return(sizeof(download_cmd) / sizeof(download_cmd[0]));
 681   1      }
 682          
 683          
 684          /******************************************************************************
 685                                          WARNING!!!                     
 686          æ­¤ä»£ç ä¸ºSDKå†…éƒ¨è°ƒç”¨,è¯·æŒ‰ç…§å®é™…dpæ•°æ®å®ç°å‡½æ•°å†…éƒ¨æ•°æ®
 687          ******************************************************************************/
 688          
 689          #ifdef SUPPORT_MCU_FIRM_UPDATE
              /**
               * @brief  å‡çº§åŒ…å¤§å°é€‰æ‹©
               * @param[in] {package_sz} å‡çº§åŒ…å¤§å°
               * @ref           0x00: 256byte (é»˜è®¤)
               * @ref           0x01: 512byte
               * @ref           0x02: 1024byte
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void upgrade_package_choose(unsigned char package_sz)
              {
                  #error "è¯·è‡ªè¡Œå®ç°è¯·è‡ªè¡Œå®ç°å‡çº§åŒ…å¤§å°é€‰æ‹©ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  unsigned short send_len = 0;
                  send_len = set_wifi_uart_byte(send_len, package_sz);
                  wifi_uart_write_frame(UPDATE_START_CMD, MCU_TX_VER, send_len);
              }
              
              /**
               * @brief  MCUè¿›å…¥å›ºä»¶å‡çº§æ¨¡å¼
               * @param[in] {value} å›ºä»¶ç¼“å†²åŒº
               * @param[in] {position} å½“å‰æ•°æ®åŒ…åœ¨äºå›ºä»¶ä½ç½®
               * @param[in] {length} å½“å‰å›ºä»¶åŒ…é•¿åº¦(å›ºä»¶åŒ…é•¿åº¦ä¸º0æ—¶,è¡¨ç¤ºå›ºä»¶åŒ…å‘é€å®Œæˆ)
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              unsigned char mcu_firm_update_handle(const unsigned char value[],unsigned long position,unsigned short len
             -gth)
              {
                  #error "è¯·è‡ªè¡Œå®ŒæˆMCUå›ºä»¶å‡çº§ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  if(length == 0) {
                      //å›ºä»¶æ•°æ®å‘é€å®Œæˆ
                    
                  }else {
                      //å›ºä»¶æ•°æ®å¤„ç†
                    
C51 COMPILER V9.52.0.0   PROTOCOL                                                          02/24/2021 22:17:58 PAGE 13  

                  }
                  
                  return SUCCESS;
              }
              #endif
 729          
 730          #ifdef SUPPORT_GREEN_TIME
              /**
               * @brief  è·å–åˆ°çš„æ ¼æ—æ—¶é—´
               * @param[in] {time} è·å–åˆ°çš„æ ¼æ—æ—¶é—´æ•°æ®
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void mcu_get_greentime(unsigned char time[])
              {
                  #error "è¯·è‡ªè¡Œå®Œæˆç›¸å…³ä»£ç ,å¹¶åˆ é™¤è¯¥è¡Œ"
                  /*
                  time[0] ä¸ºæ˜¯å¦è·å–æ—¶é—´æˆåŠŸæ ‡å¿—ï¼Œä¸º 0 è¡¨ç¤ºå¤±è´¥ï¼Œä¸º 1è¡¨ç¤ºæˆåŠŸ
                  time[1] ä¸ºå¹´ä»½ï¼Œ0x00 è¡¨ç¤º 2000 å¹´
                  time[2] ä¸ºæœˆä»½ï¼Œä» 1 å¼€å§‹åˆ°12 ç»“æŸ
                  time[3] ä¸ºæ—¥æœŸï¼Œä» 1 å¼€å§‹åˆ°31 ç»“æŸ
                  time[4] ä¸ºæ—¶é’Ÿï¼Œä» 0 å¼€å§‹åˆ°23 ç»“æŸ
                  time[5] ä¸ºåˆ†é’Ÿï¼Œä» 0 å¼€å§‹åˆ°59 ç»“æŸ
                  time[6] ä¸ºç§’é’Ÿï¼Œä» 0 å¼€å§‹åˆ°59 ç»“æŸ
                  */
                  if(time[0] == 1) {
                      //æ­£ç¡®æ¥æ”¶åˆ°wifiæ¨¡å—è¿”å›çš„æ ¼æ—æ•°æ®
                      
                  }else {
                      //è·å–æ ¼æ—æ—¶é—´å‡ºé”™,æœ‰å¯èƒ½æ˜¯å½“å‰wifiæ¨¡å—æœªè”ç½‘
                  }
              }
              #endif
 757          
 758          #ifdef SUPPORT_MCU_RTC_CHECK
              /**
               * @brief  MCUæ ¡å¯¹æœ¬åœ°RTCæ—¶é’Ÿ
               * @param[in] {time} è·å–åˆ°çš„æ ¼æ—æ—¶é—´æ•°æ®
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void mcu_write_rtctime(unsigned char time[])
              {
                  #error "è¯·è‡ªè¡Œå®ŒæˆRTCæ—¶é’Ÿå†™å…¥ä»£ç ,å¹¶åˆ é™¤è¯¥è¡Œ"
                  /*
                  Time[0] ä¸ºæ˜¯å¦è·å–æ—¶é—´æˆåŠŸæ ‡å¿—ï¼Œä¸º 0 è¡¨ç¤ºå¤±è´¥ï¼Œä¸º 1è¡¨ç¤ºæˆåŠŸ
                  Time[1] ä¸ºå¹´ä»½ï¼Œ0x00 è¡¨ç¤º 2000 å¹´
                  Time[2] ä¸ºæœˆä»½ï¼Œä» 1 å¼€å§‹åˆ°12 ç»“æŸ
                  Time[3] ä¸ºæ—¥æœŸï¼Œä» 1 å¼€å§‹åˆ°31 ç»“æŸ
                  Time[4] ä¸ºæ—¶é’Ÿï¼Œä» 0 å¼€å§‹åˆ°23 ç»“æŸ
                  Time[5] ä¸ºåˆ†é’Ÿï¼Œä» 0 å¼€å§‹åˆ°59 ç»“æŸ
                  Time[6] ä¸ºç§’é’Ÿï¼Œä» 0 å¼€å§‹åˆ°59 ç»“æŸ
                  Time[7] ä¸ºæ˜ŸæœŸï¼Œä» 1 å¼€å§‹åˆ° 7 ç»“æŸï¼Œ1ä»£è¡¨æ˜ŸæœŸä¸€
                 */
                  if(time[0] == 1) {
                      //æ­£ç¡®æ¥æ”¶åˆ°wifiæ¨¡å—è¿”å›çš„æœ¬åœ°æ—¶é’Ÿæ•°æ®
                   
                  }else {
                      //è·å–æœ¬åœ°æ—¶é’Ÿæ•°æ®å‡ºé”™,æœ‰å¯èƒ½æ˜¯å½“å‰wifiæ¨¡å—æœªè”ç½‘
                  }
              }
              #endif
C51 COMPILER V9.52.0.0   PROTOCOL                                                          02/24/2021 22:17:58 PAGE 14  

 786          
 787          #ifdef WIFI_TEST_ENABLE
 788          /**
 789           * @brief  wifiåŠŸèƒ½æµ‹è¯•åé¦ˆ
 790           * @param[in] {result} wifiåŠŸèƒ½æµ‹è¯•ç»“æœ
 791           * @ref       0: å¤±è´¥
 792           * @ref       1: æˆåŠŸ
 793           * @param[in] {rssi} æµ‹è¯•æˆåŠŸè¡¨ç¤ºwifiä¿¡å·å¼ºåº¦/æµ‹è¯•å¤±è´¥è¡¨ç¤ºé”™è¯¯ç±»å‹
 794           * @return Null
 795           * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
 796           */
 797          void wifi_test_result(unsigned char result,unsigned char rssi)
 798          {
 799   1          //#error "è¯·è‡ªè¡Œå®ç°wifiåŠŸèƒ½æµ‹è¯•æˆåŠŸ/å¤±è´¥ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
 800   1          if(result == 0) {
 801   2              //æµ‹è¯•å¤±è´¥
 802   2              if(rssi == 0x00) {
 803   3                  //æœªæ‰«æåˆ°åç§°ä¸ºtuya_mdev_testè·¯ç”±å™¨,è¯·æ£€æŸ¥
 804   3              }else if(rssi == 0x01) {
 805   3                  //æ¨¡å—æœªæˆæƒ
 806   3              }
 807   2          }else {
 808   2              //æµ‹è¯•æˆåŠŸ
 809   2              //rssiä¸ºä¿¡å·å¼ºåº¦(0-100, 0ä¿¡å·æœ€å·®ï¼Œ100ä¿¡å·æœ€å¼º)
 810   2          }
 811   1      }
 812          #endif
 813          
 814          #ifdef WEATHER_ENABLE
              /**
              * @brief  mcuæ‰“å¼€å¤©æ°”æœåŠ¡
               * @param  Null
               * @return Null
               */
              void mcu_open_weather(void)
              {
                  int i = 0;
                  char buffer[13] = {0};
                  unsigned char weather_len = 0;
                  unsigned short send_len = 0;
                  
                  weather_len = sizeof(weather_choose) / sizeof(weather_choose[0]);
                    
                  for(i=0;i<weather_len;i++) {
                      buffer[0] = sprintf(buffer+1,"w.%s",weather_choose[i]);
                      send_len = set_wifi_uart_buffer(send_len, (unsigned char *)buffer, buffer[0]+1);
                  }
                  
                  #error "è¯·æ ¹æ®æç¤ºï¼Œè‡ªè¡Œå®Œå–„æ‰“å¼€å¤©æ°”æœåŠ¡ä»£ç ï¼Œå®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  /*
                  //å½“è·å–çš„å‚æ•°æœ‰å’Œæ—¶é—´æœ‰å…³çš„å‚æ•°æ—¶(å¦‚:æ—¥å‡ºæ—¥è½)ï¼Œéœ€è¦æ­é…t.unixæˆ–è€…t.local
             -ä½¿ç”¨ï¼Œéœ€è¦è·å–çš„å‚æ•°æ•°æ®æ˜¯æŒ‰ç…§æ ¼æ—æ—¶é—´è¿˜æ˜¯æœ¬åœ°æ—¶é—´
                  buffer[0] = sprintf(buffer+1,"t.unix"); //æ ¼æ—æ—¶é—´   æˆ–ä½¿ç”¨  buffer[0] = sprintf(buffer+1,"t.lo
             -cal"); //æœ¬åœ°æ—¶é—´
                  send_len = set_wifi_uart_buffer(send_len, (unsigned char *)buffer, buffer[0]+1);
                  */
                  
                  buffer[0] = sprintf(buffer+1,"w.date.%d",WEATHER_FORECAST_DAYS_NUM);
                  send_len = set_wifi_uart_buffer(send_len, (unsigned char *)buffer, buffer[0]+1);
                  
                  wifi_uart_write_frame(WEATHER_OPEN_CMD, MCU_TX_VER, send_len);
              }
C51 COMPILER V9.52.0.0   PROTOCOL                                                          02/24/2021 22:17:58 PAGE 15  

              
              /**
               * @brief  æ‰“å¼€å¤©æ°”åŠŸèƒ½è¿”å›ç”¨æˆ·è‡ªå¤„ç†å‡½æ•°
               * @param[in] {res} æ‰“å¼€å¤©æ°”åŠŸèƒ½è¿”å›ç»“æœ
               * @ref       0: å¤±è´¥
               * @ref       1: æˆåŠŸ
               * @param[in] {err} é”™è¯¯ç 
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void weather_open_return_handle(unsigned char res, unsigned char err)
              {
                  #error "è¯·è‡ªè¡Œå®Œæˆæ‰“å¼€å¤©æ°”åŠŸèƒ½è¿”å›æ•°æ®å¤„ç†ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  unsigned char err_num = 0;
                  
                  if(res == 1) {
                      //æ‰“å¼€å¤©æ°”è¿”å›æˆåŠŸ
                  }else if(res == 0) {
                      //æ‰“å¼€å¤©æ°”è¿”å›å¤±è´¥
                      //è·å–é”™è¯¯ç 
                      err_num = err; 
                  }
              }
              
              /**
               * @brief  å¤©æ°”æ•°æ®ç”¨æˆ·è‡ªå¤„ç†å‡½æ•°
               * @param[in] {name} å‚æ•°å
               * @param[in] {type} å‚æ•°ç±»å‹
               * @ref       0: int å‹
               * @ref       1: string å‹
               * @param[in] {data} å‚æ•°å€¼çš„åœ°å€
               * @param[in] {day} å“ªä¸€å¤©çš„å¤©æ°”  0:è¡¨ç¤ºå½“å¤© å–å€¼èŒƒå›´: 0~6
               * @ref       0: ä»Šå¤©
               * @ref       1: æ˜å¤©
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void weather_data_user_handle(char *name, unsigned char type, const unsigned char *data, char day)
              {
                  #error "è¿™é‡Œä»…ç»™å‡ºç¤ºä¾‹ï¼Œè¯·è‡ªè¡Œå®Œå–„å¤©æ°”æ•°æ®å¤„ç†ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  int value_int;
                  char value_string[50];//ç”±äºæœ‰çš„å‚æ•°å†…å®¹è¾ƒå¤šï¼Œè¿™é‡Œé»˜è®¤ä¸º50ã€‚æ‚¨å¯ä»¥æ ¹æ®å®šä¹‰çš„å
             -‚æ•°ï¼Œå¯ä»¥é€‚å½“å‡å°‘è¯¥å€¼
                  
                  my_memset(value_string, '\0', 50);
                  
                  //é¦–å…ˆè·å–æ•°æ®ç±»å‹
                  if(type == 0) { //å‚æ•°æ˜¯INTå‹
                      value_int = data[0] << 24 | data[1] << 16 | data[2] << 8 | data[3];
                  }else if(type == 1) {
                      my_strcpy(value_string, data);
                  }
                  
                  //æ³¨æ„è¦æ ¹æ®æ‰€é€‰å‚æ•°ç±»å‹æ¥è·å¾—å‚æ•°å€¼ï¼ï¼ï¼
                  if(my_strcmp(name, "temp") == 0) {
                      printf("day:%d temp value is:%d\r\n", day, value_int);          //int å‹
                  }else if(my_strcmp(name, "humidity") == 0) {
                      printf("day:%d humidity value is:%d\r\n", day, value_int);      //int å‹
                  }else if(my_strcmp(name, "pm25") == 0) {
                      printf("day:%d pm25 value is:%d\r\n", day, value_int);          //int å‹
                  }else if(my_strcmp(name, "condition") == 0) {
                      printf("day:%d condition value is:%s\r\n", day, value_string);  //string å‹
C51 COMPILER V9.52.0.0   PROTOCOL                                                          02/24/2021 22:17:58 PAGE 16  

                  }
              }
              #endif
 910          
 911          #ifdef MCU_DP_UPLOAD_SYN
              /**
               * @brief  çŠ¶æ€åŒæ­¥ä¸ŠæŠ¥ç»“æœ
               * @param[in] {result} ç»“æœ
               * @ref       0: å¤±è´¥
               * @ref       1: æˆåŠŸ
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void get_upload_syn_result(unsigned char result)
              {
                  #error "è¯·è‡ªè¡Œå®ŒæˆçŠ¶æ€åŒæ­¥ä¸ŠæŠ¥ç»“æœä»£ç ,å¹¶åˆ é™¤è¯¥è¡Œ"
                    
                  if(result == 0) {
                      //åŒæ­¥ä¸ŠæŠ¥å‡ºé”™
                  }else {
                      //åŒæ­¥ä¸ŠæŠ¥æˆåŠŸ
                  }
              }
              #endif
 931          
 932          #ifdef GET_WIFI_STATUS_ENABLE
              /**
               * @brief  è·å– WIFI çŠ¶æ€ç»“æœ
               * @param[in] {result} æŒ‡ç¤º WIFI å·¥ä½œçŠ¶æ€
               * @ref       0x00: wifiçŠ¶æ€ 1 smartconfig é…ç½®çŠ¶æ€
               * @ref       0x01: wifiçŠ¶æ€ 2 AP é…ç½®çŠ¶æ€
               * @ref       0x02: wifiçŠ¶æ€ 3 WIFI å·²é…ç½®ä½†æœªè¿ä¸Šè·¯ç”±å™¨
               * @ref       0x03: wifiçŠ¶æ€ 4 WIFI å·²é…ç½®ä¸”è¿ä¸Šè·¯ç”±å™¨
               * @ref       0x04: wifiçŠ¶æ€ 5 å·²è¿ä¸Šè·¯ç”±å™¨ä¸”è¿æ¥åˆ°äº‘ç«¯
               * @ref       0x05: wifiçŠ¶æ€ 6 WIFI è®¾å¤‡å¤„äºä½åŠŸè€—æ¨¡å¼
               * @ref       0x06: wifiçŠ¶æ€ 7 WIFI è®¾å¤‡å¤„äºsmartconfig&APé…ç½®çŠ¶æ€
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void get_wifi_status(unsigned char result)
              {
                #error "è¯·è‡ªè¡Œå®Œæˆè·å– WIFI çŠ¶æ€ç»“æœä»£ç ,å¹¶åˆ é™¤è¯¥è¡Œ"
               
                  switch(result) {
                      case 0:
                          //wifiå·¥ä½œçŠ¶æ€1
                      break;
                  
                      case 1:
                          //wifiå·¥ä½œçŠ¶æ€2
                      break;
                      
                      case 2:
                          //wifiå·¥ä½œçŠ¶æ€3
                      break;
                      
                      case 3:
                          //wifiå·¥ä½œçŠ¶æ€4
                      break;
                      
                      case 4:
                          //wifiå·¥ä½œçŠ¶æ€5
C51 COMPILER V9.52.0.0   PROTOCOL                                                          02/24/2021 22:17:58 PAGE 17  

                      break;
                      
                      case 5:
                          //wifiå·¥ä½œçŠ¶æ€6
                      break;
                    
                      case 6:
                          //wifiå·¥ä½œçŠ¶æ€7
                      break;
                      
                      default:break;
                  }
              }
              #endif
 983          
 984          #ifdef WIFI_STREAM_ENABLE
              /**
               * @brief  æµæœåŠ¡å‘é€ç»“æœ
               * @param[in] {result} ç»“æœ
               * @ref       0x00: æˆåŠŸ
               * @ref       0x01: æµæœåŠ¡åŠŸèƒ½æœªå¼€å¯
               * @ref       0x02: æµæœåŠ¡å™¨æœªè¿æ¥æˆåŠŸ
               * @ref       0x03: æ•°æ®æ¨é€è¶…æ—¶
               * @ref       0x04: ä¼ è¾“çš„æ•°æ®é•¿åº¦é”™è¯¯
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void stream_trans_send_result(unsigned char result)
              {
                  #error "è¿™é‡Œä»…ç»™å‡ºç¤ºä¾‹ï¼Œè¯·è‡ªè¡Œå®Œå–„æµæœåŠ¡å‘é€ç»“æœå¤„ç†ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥
             -è¡Œ"
                  switch(result) {
                      case 0x00:
                          //æˆåŠŸ
                      break;
                      
                      case 0x01:
                          //æµæœåŠ¡åŠŸèƒ½æœªå¼€å¯
                      break;
                      
                      case 0x02:
                          //æµæœåŠ¡å™¨æœªè¿æ¥æˆåŠŸ
                      break;
                      
                      case 0x03:
                          //æ•°æ®æ¨é€è¶…æ—¶
                      break;
                      
                      case 0x04:
                          //ä¼ è¾“çš„æ•°æ®é•¿åº¦é”™è¯¯
                      break;
                      
                      default:break;
                  }
              }
              
              /**
               * @brief  å¤šåœ°å›¾æµæœåŠ¡å‘é€ç»“æœ
               * @param[in] {result} ç»“æœ
               * @ref       0x00: æˆåŠŸ
               * @ref       0x01: å¤±è´¥
               * @return Null
C51 COMPILER V9.52.0.0   PROTOCOL                                                          02/24/2021 22:17:58 PAGE 18  

               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void maps_stream_trans_send_result(unsigned char result)
              {
                  #error "è¿™é‡Œä»…ç»™å‡ºç¤ºä¾‹ï¼Œè¯·è‡ªè¡Œå®Œå–„å¤šåœ°å›¾æµæœåŠ¡å‘é€ç»“æœå¤„ç†ä»£ç ,å®Œæˆåè¯·
             -åˆ é™¤è¯¥è¡Œ"
                  switch(result) {
                      case 0x00:
                          //æˆåŠŸ
                      break;
                      
                      case 0x01:
                          //å¤±è´¥
                      break;
                      
                      default:break;
                  }
              }
              #endif
1048          
1049          #ifdef WIFI_CONNECT_TEST_ENABLE
              /**
               * @brief  è·¯ç”±ä¿¡æ¯æ¥æ”¶ç»“æœé€šçŸ¥
               * @param[in] {result} æ¨¡å—æ˜¯å¦æˆåŠŸæ¥æ”¶åˆ°æ­£ç¡®çš„è·¯ç”±ä¿¡æ¯
               * @ref       0x00: å¤±è´¥
               * @ref       0x01: æˆåŠŸ
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void wifi_connect_test_result(unsigned char result)
              {
                  #error "è¯·è‡ªè¡Œå®ç°wifiåŠŸèƒ½æµ‹è¯•æˆåŠŸ/å¤±è´¥ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  if(result == 0) {
                      //è·¯ç”±ä¿¡æ¯æ¥æ”¶å¤±è´¥ï¼Œè¯·æ£€æŸ¥å‘å‡ºçš„è·¯ç”±ä¿¡æ¯åŒ…æ˜¯å¦æ˜¯å®Œæ•´çš„JSONæ•°æ®åŒ…
                  }else {
                      //è·¯ç”±ä¿¡æ¯æ¥æ”¶æˆåŠŸï¼Œäº§æµ‹ç»“æœè¯·æ³¨æ„WIFI_STATE_CMDæŒ‡ä»¤çš„wifiå·¥ä½œçŠ¶æ€
                  }
              }
              #endif
1068          
1069          #ifdef GET_MODULE_MAC_ENABLE
              /**
               * @brief  è·å–æ¨¡å—macç»“æœ
               * @param[in] {mac} æ¨¡å— MAC æ•°æ®
               * @ref       mac[0]: ä¸ºæ˜¯å¦è·å–macæˆåŠŸæ ‡å¿—ï¼Œ0x00 è¡¨ç¤ºæˆåŠŸï¼Œ0x01 è¡¨ç¤ºå¤±è´¥
               * @ref       mac[1]~mac[6]: å½“è·å– MACåœ°å€æ ‡å¿—ä½å¦‚æœmac[0]ä¸ºæˆåŠŸï¼Œåˆ™è¡¨ç¤ºæ¨¡å—æœ‰æ•ˆçš„M
             -ACåœ°å€
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void mcu_get_mac(unsigned char mac[])
              {
                  #error "è¯·è‡ªè¡Œå®Œæˆmacè·å–ä»£ç ,å¹¶åˆ é™¤è¯¥è¡Œ"
                  /*
                  mac[0]ä¸ºæ˜¯å¦è·å–macæˆåŠŸæ ‡å¿—ï¼Œ0x00 è¡¨ç¤ºæˆåŠŸï¼Œä¸º0x01è¡¨ç¤ºå¤±è´¥
                  mac[1]~mac[6]:å½“è·å– MACåœ°å€æ ‡å¿—ä½å¦‚æœmac[0]ä¸ºæˆåŠŸï¼Œåˆ™è¡¨ç¤ºæ¨¡å—æœ‰æ•ˆçš„MACåœ°å€
                 */
                 
                  if(mac[0] == 1) {
                      //è·å–macå‡ºé”™
                  }else {
                      //æ­£ç¡®æ¥æ”¶åˆ°wifiæ¨¡å—è¿”å›çš„macåœ°å€
C51 COMPILER V9.52.0.0   PROTOCOL                                                          02/24/2021 22:17:58 PAGE 19  

                  }
              }
              #endif
1093          
1094          #ifdef GET_IR_STATUS_ENABLE
              /**
               * @brief  è·å–çº¢å¤–çŠ¶æ€ç»“æœ
               * @param[in] {result} æŒ‡ç¤ºçº¢å¤–çŠ¶æ€
               * @ref       0x00: çº¢å¤–çŠ¶æ€ 1 æ­£åœ¨å‘é€çº¢å¤–ç 
               * @ref       0x01: çº¢å¤–çŠ¶æ€ 2 å‘é€çº¢å¤–ç ç»“æŸ
               * @ref       0x02: çº¢å¤–çŠ¶æ€ 3 çº¢å¤–å­¦ä¹ å¼€å§‹
               * @ref       0x03: çº¢å¤–çŠ¶æ€ 4 çº¢å¤–å­¦ä¹ ç»“æŸ
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void get_ir_status(unsigned char result)
              {
                  #error "è¯·è‡ªè¡Œå®Œæˆçº¢å¤–çŠ¶æ€ä»£ç ,å¹¶åˆ é™¤è¯¥è¡Œ"
                  switch(result) {
                      case 0:
                          //çº¢å¤–çŠ¶æ€ 1
                      break;
                    
                      case 1:
                          //çº¢å¤–çŠ¶æ€ 2
                      break;
                        
                      case 2:
                          //çº¢å¤–çŠ¶æ€ 3
                      break;
                        
                      case 3:
                          //çº¢å¤–çŠ¶æ€ 4
                      break;
                        
                      default:break;
                  }
                  
                  wifi_uart_write_frame(GET_IR_STATUS_CMD, MCU_TX_VER, 0);
              }
              #endif
1131          
1132          #ifdef IR_TX_RX_TEST_ENABLE
              /**
               * @brief  çº¢å¤–è¿›å…¥æ”¶å‘äº§æµ‹ç»“æœé€šçŸ¥
               * @param[in] {result} æ¨¡å—æ˜¯å¦æˆåŠŸæ¥æ”¶åˆ°æ­£ç¡®çš„ä¿¡æ¯
               * @ref       0x00: å¤±è´¥
               * @ref       0x01: æˆåŠŸ
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void ir_tx_rx_test_result(unsigned char result)
              {
                  #error "è¯·è‡ªè¡Œå®ç°çº¢å¤–è¿›å…¥æ”¶å‘äº§æµ‹åŠŸèƒ½æµ‹è¯•æˆåŠŸ/å¤±è´¥ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡
             -Œ"
                  if(result == 0) {
                      //çº¢å¤–è¿›å…¥æ”¶å‘äº§æµ‹æˆåŠŸ
                  }else {
                      //çº¢å¤–è¿›å…¥æ”¶å‘äº§æµ‹å¤±è´¥ï¼Œè¯·æ£€æŸ¥å‘å‡ºçš„æ•°æ®åŒ…
                  }
              }
              #endif
C51 COMPILER V9.52.0.0   PROTOCOL                                                          02/24/2021 22:17:58 PAGE 20  

1151          
1152          #ifdef FILE_DOWNLOAD_ENABLE
              /**
               * @brief  æ–‡ä»¶ä¸‹è½½åŒ…å¤§å°é€‰æ‹©
               * @param[in] {package_sz} æ–‡ä»¶ä¸‹è½½åŒ…å¤§å°
               * @ref       0x00: 256 byte (é»˜è®¤)
               * @ref       0x01: 512 byte
               * @ref       0x02: 1024 byte
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void file_download_package_choose(unsigned char package_sz)
              {
                  #error "è¯·è‡ªè¡Œå®ç°è¯·è‡ªè¡Œå®ç°æ–‡ä»¶ä¸‹è½½åŒ…å¤§å°é€‰æ‹©ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  unsigned short send_len = 0;
                  send_len = set_wifi_uart_byte(send_len, package_sz);
                  wifi_uart_write_frame(FILE_DOWNLOAD_START_CMD, MCU_TX_VER, send_len);
              }
              
              /**
               * @brief  æ–‡ä»¶åŒ…ä¸‹è½½æ¨¡å¼
               * @param[in] {value} æ•°æ®ç¼“å†²åŒº
               * @param[in] {position} å½“å‰æ•°æ®åŒ…åœ¨äºæ–‡ä»¶ä½ç½®
               * @param[in] {length} å½“å‰æ–‡ä»¶åŒ…é•¿åº¦(é•¿åº¦ä¸º0æ—¶,è¡¨ç¤ºæ–‡ä»¶åŒ…å‘é€å®Œæˆ)
               * @return æ•°æ®å¤„ç†ç»“æœ
               * -           0(ERROR): å¤±è´¥
               * -           1(SUCCESS): æˆåŠŸ
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              unsigned char file_download_handle(const unsigned char value[],unsigned long position,unsigned short lengt
             -h)
              {
                  #error "è¯·è‡ªè¡Œå®Œæˆæ–‡ä»¶åŒ…ä¸‹è½½ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  if(length == 0) {
                      //æ–‡ä»¶åŒ…æ•°æ®å‘é€å®Œæˆ
                      
                  }else {
                      //æ–‡ä»¶åŒ…æ•°æ®å¤„ç†
                    
                  }
                  
                  return SUCCESS;
              }
              #endif
1194          
1195          #ifdef MODULE_EXPANDING_SERVICE_ENABLE
              /**
               * @brief  æ‰“å¼€æ¨¡å—æ—¶é—´æœåŠ¡é€šçŸ¥ç»“æœ
               * @param[in] {value} æ•°æ®ç¼“å†²åŒº
               * @param[in] {length} æ•°æ®é•¿åº¦
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void open_module_time_serve_result(const unsigned char value[], unsigned short length)
              {
                  #error "è¯·è‡ªè¡Œå®ç°æ¨¡å—æ—¶é—´æœåŠ¡é€šçŸ¥ç»“æœä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  unsigned char sub_cmd = value[0];
                  
                  switch(sub_cmd) {
                      case 0x01: { //å­å‘½ä»¤  æ‰“å¼€æ¨¡å—æ—¶é—´æœåŠ¡é€šçŸ¥
                          if(0x02 != length) {
                              //æ•°æ®é•¿åº¦é”™è¯¯
C51 COMPILER V9.52.0.0   PROTOCOL                                                          02/24/2021 22:17:58 PAGE 21  

                              return;
                          }
                          
                          if(value[1] == 0) {
                              //æœåŠ¡å¼€å¯æˆåŠŸ
                          }else {
                              //æœåŠ¡å¼€å¯å¤±è´¥
                          }
                      }
                      break;
                      
                      case 0x02: {  //å­å‘½ä»¤  æ¨¡å—æ—¶é—´æœåŠ¡é€šçŸ¥
                          if(0x09 != length) {
                              //æ•°æ®é•¿åº¦é”™è¯¯
                              return;
                          }
                          
                          unsigned char time_type = value[1]; //0x00:æ ¼æ—æ—¶é—´  0x01:æœ¬åœ°æ—¶é—´
                          unsigned char time_data[7];
                          
                          my_memcpy(time_data, value + 2, length - 2);
                          /*
                          Data[0]ä¸ºå¹´ä»½, 0x00è¡¨ç¤º2000å¹´
                          Data[1]ä¸ºæœˆä»½ï¼Œä»1å¼€å§‹åˆ°12ç»“æŸ
                          Data[2]ä¸ºæ—¥æœŸï¼Œä»1å¼€å§‹åˆ°31ç»“æŸ
                          Data[3]ä¸ºæ—¶é’Ÿï¼Œä»0å¼€å§‹åˆ°23ç»“æŸ
                          Data[4]ä¸ºåˆ†é’Ÿï¼Œä»0å¼€å§‹åˆ°59ç»“æŸ
                          Data[5]ä¸ºç§’é’Ÿï¼Œä»0å¼€å§‹åˆ°15ç»“æŸ
                          Data[6]ä¸ºæ˜ŸæœŸï¼Œä»1å¼€å§‹åˆ°7ç»“æŸï¼Œ1ä»£è¡¨æ˜ŸæœŸä¸€
                          */
                          
                          //åœ¨æ­¤å¤„æ·»åŠ æ—¶é—´æ•°æ®å¤„ç†ä»£ç ï¼Œtime_typeä¸ºæ—¶é—´ç±»å‹
                          
                          unsigned short send_len = 0;
                          send_len = set_wifi_uart_byte(send_len,sub_cmd);
                          wifi_uart_write_frame(MODULE_EXTEND_FUN_CMD, MCU_TX_VER, send_len);
                      }
                      break;
                      
                      case 0x03: {  //å­å‘½ä»¤  ä¸»åŠ¨è¯·æ±‚å¤©æ°”æœåŠ¡æ•°æ®
                          if(0x02 != length) {
                              //æ•°æ®é•¿åº¦é”™è¯¯
                              return;
                          }
                          
                          if(value[1] == 0) {
                              //æˆåŠŸ
                          }else {
                              //å¤±è´¥
                          }
                      }
                      break;
                      
                      case 0x04: {  //å­å‘½ä»¤  æ‰“å¼€æ¨¡å—é‡ç½®çŠ¶æ€é€šçŸ¥
                          if(0x02 != length) {
                              //æ•°æ®é•¿åº¦é”™è¯¯
                              return;
                          }
                          
                          if(value[1] == 0) {
                              //æˆåŠŸ
                          }else {
C51 COMPILER V9.52.0.0   PROTOCOL                                                          02/24/2021 22:17:58 PAGE 22  

                              //å¤±è´¥
                          }
                      }
                      break;
                      
                      case 0x05: {  //å­å‘½ä»¤  æ¨¡å—é‡ç½®çŠ¶æ€é€šçŸ¥
                          if(0x02 != length) {
                              //æ•°æ®é•¿åº¦é”™è¯¯
                              return;
                          }
                          
                          switch(value[1]) {
                              case 0x00:
                                  //æ¨¡å—æœ¬åœ°é‡ç½®
                                  
                              break;
                              case 0x01:
                                  //APPè¿œç¨‹é‡ç½®
                                  
                              break;
                              case 0x02:
                                  //APPæ¢å¤å‡ºå‚é‡ç½®
                                  
                              break;
                              default:break;
                          }
                          
                          unsigned short send_len = 0;
                          send_len = set_wifi_uart_byte(send_len, sub_cmd);
                          wifi_uart_write_frame(MODULE_EXTEND_FUN_CMD, MCU_TX_VER, send_len);
                      }
                      break;
                      
                      default:break;
                  }
              }
              #endif
1311          
1312          #ifdef BLE_RELATED_FUNCTION_ENABLE
              /**
               * @brief  è“ç‰™åŠŸèƒ½æ€§æµ‹è¯•ç»“æœ
               * @param[in] {value} æ•°æ®ç¼“å†²åŒº
               * @param[in] {length} æ•°æ®é•¿åº¦
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void BLE_test_result(const unsigned char value[], unsigned short length)
              {
                  #error "è¯·è‡ªè¡Œå®ç°è“ç‰™åŠŸèƒ½æ€§æµ‹è¯•ç»“æœä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  unsigned char sub_cmd = value[0];
                  
                  if(0x03 != length) {
                      //æ•°æ®é•¿åº¦é”™è¯¯
                      return;
                  }
                  
                  if(0x01 != sub_cmd) {
                      //å­å‘½ä»¤é”™è¯¯
                      return;
                  }
                  
                  unsigned char result = value[1];
C51 COMPILER V9.52.0.0   PROTOCOL                                                          02/24/2021 22:17:58 PAGE 23  

                  unsigned char rssi = value[2];
                      
                  if(result == 0) {
                      //æµ‹è¯•å¤±è´¥
                      if(rssi == 0x00) {
                          //æœªæ‰«æåˆ°åç§°ä¸º ty_mdevè“ç‰™ä¿¡æ ‡,è¯·æ£€æŸ¥
                      }else if(rssi == 0x01) {
                          //æ¨¡å—æœªæˆæƒ
                      }
                  }else if(result == 0x01) {
                      //æµ‹è¯•æˆåŠŸ
                      //rssiä¸ºä¿¡å·å¼ºåº¦(0-100, 0ä¿¡å·æœ€å·®ï¼Œ100ä¿¡å·æœ€å¼º)
                  }
              }
              #endif
1351          
1352          #ifdef VOICE_MODULE_PROTOCOL_ENABLE
              /**
               * @brief  è·å–è¯­éŸ³çŠ¶æ€ç ç»“æœ
               * @param[in] {result} è¯­éŸ³çŠ¶æ€ç 
               * @ref       0x00: ç©ºé—²
               * @ref       0x01: micé™éŸ³çŠ¶æ€
               * @ref       0x02: å”¤é†’
               * @ref       0x03: æ­£åœ¨å½•éŸ³
               * @ref       0x04: æ­£åœ¨è¯†åˆ«
               * @ref       0x05: è¯†åˆ«æˆåŠŸ
               * @ref       0x06: è¯†åˆ«å¤±è´¥
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void get_voice_state_result(unsigned char result)
              {
                  #error "è¯·è‡ªè¡Œå®ç°è·å–è¯­éŸ³çŠ¶æ€ç ç»“æœå¤„ç†ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  switch(result) {
                      case 0:
                          //ç©ºé—²
                      break;
                  
                      case 1:
                          //micé™éŸ³çŠ¶æ€
                      break;
                      
                      case 2:
                          //å”¤é†’
                      break;
                      
                      case 3:
                          //æ­£åœ¨å½•éŸ³
                      break;
                      
                      case 4:
                          //æ­£åœ¨è¯†åˆ«
                      break;
                  
                      case 5:
                          //è¯†åˆ«æˆåŠŸ
                      break;
                      
                      case 6:
                          //è¯†åˆ«å¤±è´¥
                      break;
                      
C51 COMPILER V9.52.0.0   PROTOCOL                                                          02/24/2021 22:17:58 PAGE 24  

                    default:break;
                  }
              }
              
              /**
               * @brief  MICé™éŸ³è®¾ç½®ç»“æœ
               * @param[in] {result} è¯­éŸ³çŠ¶æ€ç 
               * @ref       0x00: mic å¼€å¯
               * @ref       0x01: mic é™éŸ³
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void set_voice_MIC_silence_result(unsigned char result)
              {
                  #error "è¯·è‡ªè¡Œå®ç°MICé™éŸ³è®¾ç½®å¤„ç†ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  if(result == 0) {
                      //mic å¼€å¯
                  }else {
                      //mic é™éŸ³
                  }
              }
              
              /**
               * @brief  speakeréŸ³é‡è®¾ç½®ç»“æœ
               * @param[in] {result} éŸ³é‡å€¼
               * @ref       0~10: éŸ³é‡èŒƒå›´
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void set_speaker_voice_result(unsigned char result)
              {
                  #error "è¯·è‡ªè¡Œå®ç°speakeréŸ³é‡è®¾ç½®ç»“æœå¤„ç†ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  
              }
              
              /**
               * @brief  éŸ³é¢‘äº§æµ‹ç»“æœ
               * @param[in] {result} éŸ³é¢‘äº§æµ‹çŠ¶æ€
               * @ref       0x00: å…³é—­éŸ³é¢‘äº§æµ‹
               * @ref       0x01: mic1éŸ³é¢‘ç¯è·¯æµ‹è¯•
               * @ref       0x02: mic2éŸ³é¢‘ç¯è·¯æµ‹è¯•
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void voice_test_result(unsigned char result)
              {
                  #error "è¯·è‡ªè¡Œå®ç°éŸ³é¢‘äº§æµ‹ç»“æœå¤„ç†ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  if(result == 0x00) {
                      //å…³é—­éŸ³é¢‘äº§æµ‹
                  }else if(result == 0x01) {
                      //mic1éŸ³é¢‘ç¯è·¯æµ‹è¯•
                  }else if(result == 0x02) {
                      //mic2éŸ³é¢‘ç¯è·¯æµ‹è¯•
                  }
              }
              
              /**
               * @brief  å”¤é†’äº§æµ‹ç»“æœ
               * @param[in] {result} å”¤é†’è¿”å›å€¼
               * @ref       0x00: å”¤é†’æˆåŠŸ
               * @ref       0x01: å”¤é†’å¤±è´¥(10sè¶…æ—¶å¤±è´¥)
               * @return Null
C51 COMPILER V9.52.0.0   PROTOCOL                                                          02/24/2021 22:17:58 PAGE 25  

               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void voice_awaken_test_result(unsigned char result)
              {
                  #error "è¯·è‡ªè¡Œå®ç°å”¤é†’äº§æµ‹ç»“æœå¤„ç†ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                  if(result == 0x00) {
                      //å”¤é†’æˆåŠŸ
                  }else if(result == 0x01) {
                      //å”¤é†’å¤±è´¥
                  }
              }
              
              /**
               * @brief  è¯­éŸ³æ¨¡ç»„æ‰©å±•åŠŸèƒ½
               * @param[in] {value} æ•°æ®ç¼“å†²åŒº
               * @param[in] {length} æ•°æ®é•¿åº¦
               * @return Null
               * @note   MCUéœ€è¦è‡ªè¡Œå®ç°è¯¥åŠŸèƒ½
               */
              void voice_module_extend_fun(const unsigned char value[], unsigned short length)
              {
                  unsigned char sub_cmd = value[0];
                  unsigned char play;
                  unsigned char bt_play;
                  unsigned short send_len = 0;
                
                  switch(sub_cmd) {
                      case 0x00: { //å­å‘½ä»¤  MCUåŠŸèƒ½è®¾ç½®
                          if(0x02 != length) {
                              //æ•°æ®é•¿åº¦é”™è¯¯
                              return;
                          }
                          
                          if(value[1] == 0) {
                              //æˆåŠŸ
                          }else {
                              //å¤±è´¥
                          }
                      }
                      break;
                      
                      case 0x01: {  //å­å‘½ä»¤  çŠ¶æ€é€šçŸ¥
                          if(0x02 > length) {
                              //æ•°æ®é•¿åº¦é”™è¯¯
                              return;
                          }
                          
                          unsigned char play = 0xff;
                          unsigned char bt_play = 0xff;
                          
                          const char *str_buff = (const char *)&value[1];
                          const char *str_result = NULL;
                          
                          str_result = strstr(str_buff,"play") + my_strlen("play") + 2;
                          if(NULL == str_result) {
                              //æ•°æ®é”™è¯¯
                              goto ERR_EXTI;
                          }
                          
                          if(0 == memcmp(str_result, "true", my_strlen("true"))) {
                              play = 1;
                          }else if(0 == memcmp(str_result, "false", my_strlen("false"))) {
C51 COMPILER V9.52.0.0   PROTOCOL                                                          02/24/2021 22:17:58 PAGE 26  

                              play = 0;
                          }else {
                              //æ•°æ®é”™è¯¯
                              goto ERR_EXTI;
                          }
                          
                          str_result = strstr(str_buff,"bt_play") + my_strlen("bt_play") + 2;
                          if(NULL == str_result) {
                              //æ•°æ®é”™è¯¯
                              goto ERR_EXTI;
                          }
                          
                          if(0 == memcmp(str_result, "true", my_strlen("true"))) {
                              bt_play = 1;
                          }else if(0 == memcmp(str_result, "false", my_strlen("false"))) {
                              bt_play = 0;
                          }else {
                              //æ•°æ®é”™è¯¯
                              goto ERR_EXTI;
                          }
                          
                          #error "è¯·è‡ªè¡Œå®ç°è¯­éŸ³æ¨¡ç»„çŠ¶æ€é€šçŸ¥å¤„ç†ä»£ç ,å®Œæˆåè¯·åˆ é™¤è¯¥è¡Œ"
                          //MCUè®¾ç½®æš‚ä»…æ”¯æŒâ€æ’­æ”¾/æš‚åœâ€ â€è“ç‰™å¼€å…³â€
                          //play    æ’­æ”¾/æš‚åœåŠŸèƒ½  1(æ’­æ”¾) / 0(æš‚åœ)
                          //bt_play è“ç‰™å¼€å…³åŠŸèƒ½   1(å¼€)   / 0(å…³)
                          
                          
                          
                          send_len = 0;
                          send_len = set_wifi_uart_byte(send_len, sub_cmd);
                          send_len = set_wifi_uart_byte(send_len, 0x00);
                          wifi_uart_write_frame(MODULE_EXTEND_FUN_CMD, MCU_TX_VER, send_len);
                      }
                      break;
              
                      default:break;
                  }
                  
                  return;
              
              ERR_EXTI:
                  send_len = 0;
                  send_len = set_wifi_uart_byte(send_len, sub_cmd);
                  send_len = set_wifi_uart_byte(send_len, 0x01);
                  wifi_uart_write_frame(MODULE_EXTEND_FUN_CMD, MCU_TX_VER, send_len);
                  return;
              }
              #endif
1570          
1571          
1572          
1573          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    962    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     44       4
   PDATA SIZE       =   ----      53
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
C51 COMPILER V9.52.0.0   PROTOCOL                                                          02/24/2021 22:17:58 PAGE 27  

END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
